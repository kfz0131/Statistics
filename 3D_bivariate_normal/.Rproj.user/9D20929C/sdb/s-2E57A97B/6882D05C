{
    "contents" : "# Bivariate normal distribution\nlibrary(mvtnorm)\nlibrary(plot3D)\n# type in parameter\nmu_x = 0\nmu_y = 10\nsx = 0.15\nsy = 1\nr = 0.9\nn = 100\ncutoff <- 3.5\n\n# Create grid of interesting values.\nx <- seq(mu_x - cutoff * sx, mu_x + cutoff * sx, length = n)\ny <- seq(mu_y - cutoff * sy, mu_y + cutoff * sy, length = n)\n\n\n# create the mean matrix (u) and covariance matrix (s)\nu <- c(mu_x, mu_y)\ncovariance <- r * sx * sy\ns <- matrix(c(sx ^ 2, covariance, covariance, sy ^ 2), 2)\n\n# setup matrix to store densities\nbivariate_normal <- matrix(0, n, n)\n\n# calculates the densities\nfor (i in seq_along(x)) {\n  for (j in seq_along(y)) {\n    bivariate_normal[i, j] <- dmvnorm(c(x[i], y[j]), mean = u, sigma = s)\n  }\n}\n\n# slide bar parameter\nvertical_rotation = 0\nhorizontal_rotation = 0\n\n# plots\npersp3D(\n  x,\n  y,\n  bivariate_normal,\n  colvar = bivariate_normal,\n  phi = vertical_rotation,\n  theta = horizontal_rotation,\n  ticktype = \"detailed\",\n  expand = 0.5,\n  shade = 0.2,\n  xlab = \"x\",\n  ylab = \"y\",\n  zlab = \"z = f(x, y)\",\n  contour = TRUE\n)\n#-------------------------------------------------------------------------------\n# wrap-up function\nbivariate_normal_3d <- function(mu_x,mu_y,sx,sy,r,n,cutoff,\n                               vertical_rotation,horizontal_rotation){\n  # Use mvtnorm library and plot3D library\n  library(mvtnorm)\n  library(plot3D)\n  # Create grid of interesting values.\n  x <- seq(mu_x - cutoff * sx, mu_x + cutoff * sx, length = n)\n  y <- seq(mu_y - cutoff * sy, mu_y + cutoff * sy, length = n)\n  \n  \n  # create the mean matrix (u) and covariance matrix (s)\n  u <- c(mu_x, mu_y)\n  covariance <- r * sx * sy\n  s <- matrix(c(sx ^ 2, covariance, covariance, sy ^ 2), 2)\n  \n  # setup matrix to store densities\n  bivariate_normal <- matrix(0, n, n)\n  \n  # calculates the densities\n  for (i in seq_along(x)) {\n    for (j in seq_along(y)) {\n      bivariate_normal[i, j] <- dmvnorm(c(x[i], y[j]), mean = u, sigma = s)\n    }\n  }\n  \n  # plots\n  persp3D(\n    x,\n    y,\n    bivariate_normal,\n    colvar = bivariate_normal,\n    phi = vertical_rotation,\n    theta = horizontal_rotation,\n    ticktype = \"detailed\",\n    expand = 0.5,\n    shade = 0.2,\n    xlab = \"x\",\n    ylab = \"y\",\n    zlab = \"z = f(x, y)\",\n    contour = TRUE\n  )\n}\n\n# local test\nbivariate_normal_3d(0,10,0.15,1,0.6,100,3.5,0,0)\n\n# Run the app with code on the webpage\nrunApp(\"honor\", display.mode = \"showcase\")\n\n#------------------------------------------------------------------------------\n# Conditional 3D plot\n# wrap-up function\ncondition_3d <- function(mu_x,mu_y,sx,sy,r,n,cutoff,\n                                vertical_rotation,horizontal_rotation,cx,cy){\n  # Use mvtnorm library and plot3D library\n  library(mvtnorm)\n  library(plot3D)\n  # Create grid of interesting values.\n  x <- seq(mu_x - cutoff * sx, mu_x + cutoff * sx, length = n)\n  y <- seq(mu_y - cutoff * sy, mu_y + cutoff * sy, length = n)\n  \n  \n  # create the mean matrix (u) and covariance matrix (s)\n  u <- c(mu_x, mu_y)\n  covariance <- r * sx * sy\n  s <- matrix(c(sx ^ 2, covariance, covariance, sy ^ 2), 2)\n  \n  # setup matrix to store densities\n  bivariate_normal <- matrix(0, n, n)\n  \n  # calculates the densities\n  if(missing(cx) & missing(cy)){\n    for (i in seq_along(x)) {\n      for (j in seq_along(y)) {\n        bivariate_normal[i, j] <- dmvnorm(c(x[i], y[j]), mean = u, sigma = s)\n      }\n    }\n    # plots\n    persp3D(\n      x,\n      y,\n      bivariate_normal,\n      colvar = bivariate_normal,\n      phi = vertical_rotation,\n      theta = horizontal_rotation,\n      ticktype = \"detailed\",\n      expand = 0.5,\n      shade = 0.2,\n      xlab = \"x\",\n      ylab = \"y\",\n      zlab = \"z = f(x, y)\"\n    )\n  }\n  # condition on given X\n  else if(missing(cy)){\n    for (i in which.min(abs(x - cx)):length(x) ) {\n      for (j in seq_along(y)) {\n        bivariate_normal[i, j] <- dmvnorm(c(x[i], y[j]), mean = u, sigma = s)\n      }\n    }\n    # plots\n    persp3D(\n      x,\n      y,\n      bivariate_normal,\n      colvar = bivariate_normal,\n      phi = vertical_rotation,\n      theta = horizontal_rotation,\n      ticktype = \"detailed\",\n      expand = 0.5,\n      shade = 0.2,\n      xlab = \"x\",\n      ylab = \"y\",\n      zlab = \"z = f(x, y)\"\n    )\n  }\n  # condition on given Y\n  else if(missing(cx)){\n    for (i in seq_along(x)) {\n      for (j in which.min(abs(y - cy)):length(y)) {\n        bivariate_normal[i, j] <- dmvnorm(c(x[i], y[j]), mean = u, sigma = s)\n      }\n    }\n    # plots\n    persp3D(\n      x,\n      y,\n      bivariate_normal,\n      colvar = bivariate_normal,\n      phi = vertical_rotation,\n      theta = horizontal_rotation,\n      ticktype = \"detailed\",\n      expand = 0.5,\n      shade = 0.2,\n      xlab = \"x\",\n      ylab = \"y\",\n      zlab = \"z = f(x, y)\"\n    )\n  }\n  # For debug use. This should not happen\n  else{\n    for (i in which.min(abs(x - cx)):length(x)) {\n      for (j in  which.min(abs(y - cy)):length(y)) {\n        bivariate_normal[i, j] <- dmvnorm(c(x[i], y[j]), mean = u, sigma = s)\n      }\n    }\n    # plots\n    persp3D(\n      x,\n      y,\n      bivariate_normal,\n      colvar = bivariate_normal,\n      phi = vertical_rotation,\n      theta = horizontal_rotation,\n      ticktype = \"detailed\",\n      expand = 0.5,\n      shade = 0.2,\n      xlab = \"x\",\n      ylab = \"y\",\n      zlab = \"z = f(x, y)\"\n    )\n  }\n}\n\n# local test\ncondition_3d(0,10,0.15,1,0.6,100,3.5,0,0,cy=11)\n#------------------------------------------------------------------------------------------------\n# Contour plot\n\n# input\nux <- 0\nsx <- 0.15\nuy <- 10\nsy <- 1\nrho <- 0.6\nxlabel <- \"x\"\nylabel <- \"y\"\n\n# parameters\nmu <- c(ux, uy)\ns12 <- rho * sx * sy\nsigma  <- cbind(c(sx^2,s12),c(s12,sy^2)) \n\nxmax <- ux + 3.5 * sx\nxmin <- ux - 3.5 * sx\n\nymax <- uy + 3.5 * sy\nymin <- uy - 3.5 * sy\n\n# Basic contour plot\n\nplot(\n  ellipse(sigma, level = 0.90)[ ,1] + mu[1],\n  ellipse(sigma, level = 0.90)[ ,2] + mu[2],\n  xlab = xlabel, ylab = ylabel,\n  xlim = c(xmin, xmax), ylim = c(ymin, ymax), type=\"l\")\n\npoints(mu[1], mu[2], pch=3)\n\nlines(\n  ellipse(sigma, level = 0.999)[ ,1] + mu[1],\n  ellipse(sigma, level = 0.999)[ ,2] + mu[2],\n  xlim = c(xmin, xmax), ylim = c(ymin, ymax), type=\"l\")\n\nlines(\n  ellipse(sigma, level = 0.99)[ ,1] + mu[1],\n  ellipse(sigma, level = 0.99)[ ,2] + mu[2],\n  xlim = c(xmin, xmax), ylim = c(ymin, ymax), type=\"l\")\n\nlines(\n  ellipse(sigma, level = 0.50)[ ,1] + mu[1],\n  ellipse(sigma, level = 0.50)[ ,2] + mu[2],\n  xlim = c(xmin, xmax), ylim = c(ymin, ymax), type=\"l\")\n\n#points(mu[1], mu[2], pch=3) ? why i need to plot the center point again\n\n# Shade\n\ncx <- 0.2\ncy <- 11\n\nabline(v = cx, col = \"blue\")\nfor(i in seq(cx, cx*5, by = 0.01)){\n  abline(v = i, col = \"blue\", lty = 3)\n}\n\nabline(h = cy, col = \"blue\")\nfor(i in seq(cy, cy * 5, by = 0.1)){\n  abline(h = i, col = \"blue\", lty = 3)\n}\n\n\n\n#-----------------------------------------------------------------------\n# Slice of probability based on given X or Y\n# Conditional 3D plot\n# wrap-up function\nslice_3d <- function(mu_x,mu_y,sx,sy,r,n,cutoff,\n                         vertical_rotation,horizontal_rotation,cx,cy){\n  # Use mvtnorm library and plot3D library\n  library(mvtnorm)\n  library(plot3D)\n  # Create grid of interesting values.\n  x <- seq(mu_x - cutoff * sx, mu_x + cutoff * sx, length = n)\n  y <- seq(mu_y - cutoff * sy, mu_y + cutoff * sy, length = n)\n  \n  \n  # create the mean matrix (u) and covariance matrix (s)\n  u <- c(mu_x, mu_y)\n  covariance <- r * sx * sy\n  s <- matrix(c(sx ^ 2, covariance, covariance, sy ^ 2), 2)\n  \n  # setup matrix to store densities\n  bivariate_normal <- matrix(0, n, n)\n  \n  # calculates the densities\n  if(missing(cx) & missing(cy)){\n    for (i in seq_along(x)) {\n      for (j in seq_along(y)) {\n        bivariate_normal[i, j] <- dmvnorm(c(x[i], y[j]), mean = u, sigma = s)\n      }\n    }\n    # plots\n    persp3D(\n      x,\n      y,\n      bivariate_normal,\n      colvar = bivariate_normal,\n      phi = vertical_rotation,\n      theta = horizontal_rotation,\n      ticktype = \"detailed\",\n      expand = 0.5,\n      shade = 0.2,\n      xlab = \"x\",\n      ylab = \"y\",\n      zlab = \"z = f(x, y)\"\n    )\n  }\n  # condition on given X\n  else if(missing(cy)){\n    i = which.min(abs(x - givenX))\n    for (j in seq_along(y)) {\n      bivariate_normal[i, j] <- dmvnorm(c(x[i], y[j]), mean = u, sigma = s)\n    }\n    # plots\n    persp3D(\n      x,\n      y,\n      bivariate_normal,\n      colvar = bivariate_normal,\n      phi = vertical_rotation,\n      theta = horizontal_rotation,\n      ticktype = \"detailed\",\n      expand = 0.5,\n      shade = 0.2,\n      xlab = \"x\",\n      ylab = \"y\",\n      zlab = \"z = f(x, y)\"\n    )\n  }\n  # condition on given Y\n  else if(missing(cx)){\n    j = which.min(abs(y - givenY))\n    for (i in seq_along(x)) {\n      bivariate_normal[i, j] <- dmvnorm(c(x[i], y[j]), mean = u, sigma = s)\n    }\n    \n    # plots\n    persp3D(\n      x,\n      y,\n      bivariate_normal,\n      colvar = bivariate_normal,\n      phi = vertical_rotation,\n      theta = horizontal_rotation,\n      ticktype = \"detailed\",\n      expand = 0.5,\n      shade = 0.2,\n      xlab = \"x\",\n      ylab = \"y\",\n      zlab = \"z = f(x, y)\"\n    )\n  }\n  # For debug use. This should not happen\n  else{\n    plot(1,1)\n  }\n}\n\n# local test\nslice_3d(0,10,0.15,1,0.6,100,3.5,60,0)\n\n#---------------------------------------------------------------------\n# Work on list\n# 1. Set the flat contour plot(does not need to change with the rotation) \n#    along with the 3D bivariate normal plot\n# 2. Create a click button, when it is clicked, show the argument of condition on X and Y\n# 3. Show one slice of joint probability given X or Y on 3D dimension\n#    (Go up and down a little bit for the given X)\n# 4. Show the 3D condition plot\n# 5. Create a github account to share the 3D bivariate code\n# 6. Set up own Shiny url: https://www.rstudio.com/pricing/\n",
    "created" : 1445802442878.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1994618433",
    "id" : "6882D05C",
    "lastKnownWriteTime" : 1450125713,
    "path" : "C:/D/Study/James Scholar Program/Fall 2015 STAT 420/Honor/honor.R",
    "project_path" : "honor.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}