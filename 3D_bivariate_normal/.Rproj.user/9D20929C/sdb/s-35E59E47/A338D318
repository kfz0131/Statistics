{
    "contents" : "shinyServer(function(input, output) {\n  # 3D Plot \n  output$distPlot <- renderPlot({\n    library(mvtnorm)\n    library(plot3D)\n    # wrap-up function\n    bivariate_normal_3d <- function(mu_x,mu_y,sx,sy,r,n,cutoff,\n                                    vertical_rotation,horizontal_rotation){\n      if(n=='Low'){\n        n = 25\n      }\n      else{\n        n = 100\n      }\n      # Use mvtnorm library\n      library(mvtnorm)\n      # Create grid of interesting values.\n      x <- seq(mu_x - cutoff * sx, mu_x + cutoff * sx, length = n)\n      y <- seq(mu_y - cutoff * sy, mu_y + cutoff * sy, length = n)\n      \n      \n      # create the mean matrix (u) and covariance matrix (s)\n      u <- c(mu_x, mu_y)\n      covariance <- r * sx * sy\n      s <- matrix(c(sx ^ 2, covariance, covariance, sy ^ 2), 2)\n      \n      # setup matrix to store densities\n      bivariate_normal <- matrix(0, n, n)\n      \n      # calculates the densities\n      for (i in seq_along(x)) {\n        for (j in seq_along(y)) {\n          bivariate_normal[i, j] <- dmvnorm(c(x[i], y[j]), mean = u, sigma = s)\n        }\n      }\n      \n      # plots\n      persp3D(\n        x,\n        y,\n        bivariate_normal,\n        colvar = bivariate_normal,\n        phi = vertical_rotation,\n        theta = horizontal_rotation,\n        ticktype = \"detailed\",\n        expand = 0.5,\n        shade = 0.2,\n        xlab = \"x\",\n        ylab = \"y\",\n        zlab = \"z = f(x, y)\",\n        box = TRUE,\n        contour = TRUE\n      )\n    }\n    \n    # Output\n    bivariate_normal_3d(input$mu_x,input$mu_y,input$sx,input$sy,\n                        input$r,input$resolution,3.5,input$vr,input$hr)\n    \n  },\n    height = 1000, width = 800\n  )\n  #---------------------------------------------------------------------------\n  # Condition Plot\n  output$conditionPlot <- renderPlot({\n    library(mvtnorm)\n    library(plot3D)\n    # wrap-up function\n    \n    condition_3d <- function(mu_x,mu_y,sx,sy,r,n,cutoff,\n                             vertical_rotation,horizontal_rotation,cx,cy){\n      if(n=='Low'){\n        n = 25\n      }\n      else{\n        n = 100\n      }\n      # Use mvtnorm library and plot3D library\n      library(mvtnorm)\n      library(plot3D)\n      # Create grid of interesting values.\n      x <- seq(mu_x - cutoff * sx, mu_x + cutoff * sx, length = n)\n      y <- seq(mu_y - cutoff * sy, mu_y + cutoff * sy, length = n)\n      \n      \n      # create the mean matrix (u) and covariance matrix (s)\n      u <- c(mu_x, mu_y)\n      covariance <- r * sx * sy\n      s <- matrix(c(sx ^ 2, covariance, covariance, sy ^ 2), 2)\n      \n      # setup matrix to store densities\n      bivariate_normal <- matrix(0, n, n)\n      \n      # calculates the densities\n      if(missing(cx) & missing(cy)){\n        for (i in seq_along(x)) {\n          for (j in seq_along(y)) {\n            bivariate_normal[i, j] <- dmvnorm(c(x[i], y[j]), mean = u, sigma = s)\n          }\n        }\n        # plots\n        persp3D(\n          x,\n          y,\n          bivariate_normal,\n          colvar = bivariate_normal,\n          phi = vertical_rotation,\n          theta = horizontal_rotation,\n          ticktype = \"detailed\",\n          expand = 0.5,\n          shade = 0.2,\n          xlab = \"x\",\n          ylab = \"y\",\n          zlab = \"z = f(x, y)\"\n        )\n      }\n      # condition on given X\n      else if(missing(cy)){\n        for (i in which.min(abs(x - cx)):length(x) ) {\n          for (j in seq_along(y)) {\n            bivariate_normal[i, j] <- dmvnorm(c(x[i], y[j]), mean = u, sigma = s)\n          }\n        }\n        # plots\n        persp3D(\n          x,\n          y,\n          bivariate_normal,\n          colvar = bivariate_normal,\n          phi = vertical_rotation,\n          theta = horizontal_rotation,\n          ticktype = \"detailed\",\n          expand = 0.5,\n          shade = 0.2,\n          xlab = \"x\",\n          ylab = \"y\",\n          zlab = \"z = f(x, y)\"\n        )\n      }\n      # condition on given Y\n      else if(missing(cx)){\n        for (i in seq_along(x)) {\n          for (j in which.min(abs(y - cy)):length(y)) {\n            bivariate_normal[i, j] <- dmvnorm(c(x[i], y[j]), mean = u, sigma = s)\n          }\n        }\n        # plots\n        persp3D(\n          x,\n          y,\n          bivariate_normal,\n          colvar = bivariate_normal,\n          phi = vertical_rotation,\n          theta = horizontal_rotation,\n          ticktype = \"detailed\",\n          expand = 0.5,\n          shade = 0.2,\n          xlab = \"x\",\n          ylab = \"y\",\n          zlab = \"z = f(x, y)\"\n        )\n      }\n      # For debug use. This should not happen\n      else{\n        for (i in which.min(abs(x - cx)):length(x)) {\n          for (j in  which.min(abs(y - cy)):length(y)) {\n            bivariate_normal[i, j] <- dmvnorm(c(x[i], y[j]), mean = u, sigma = s)\n          }\n        }\n        # plots\n        persp3D(\n          x,\n          y,\n          bivariate_normal,\n          colvar = bivariate_normal,\n          phi = vertical_rotation,\n          theta = horizontal_rotation,\n          ticktype = \"detailed\",\n          expand = 0.5,\n          shade = 0.2,\n          xlab = \"x\",\n          ylab = \"y\",\n          zlab = \"z = f(x, y)\"\n        )\n      }\n    }\n    # Output\n    condition_3d(input$mu_x,input$mu_y,input$sx,input$sy,input$r,input$resolution,3.5,input$vr,input$hr,cx=0.02)\n  },\n    height = 1000, width = 800\n  )\n  #---------------------------------------------------------------------------\n  # Contour Plot\n  output$contour <- renderPlot({\n    library(plot3D)\n    # wrap-up function\n    contourplot <- function(mu_x,mu_y,sx,sy,r,n,cutoff,\n                            vertical_rotation,horizontal_rotation){\n      if(n=='Low'){\n        n = 25\n      }\n      else{\n        n = 100\n      }\n      # Use mvtnorm library\n      library(mvtnorm)\n      # Create grid of interesting values.\n      x <- seq(mu_x - cutoff * sx, mu_x + cutoff * sx, length = n)\n      y <- seq(mu_y - cutoff * sy, mu_y + cutoff * sy, length = n)\n      \n      \n      # create the mean matrix (u) and covariance matrix (s)\n      u <- c(mu_x, mu_y)\n      covariance <- r * sx * sy\n      s <- matrix(c(sx ^ 2, covariance, covariance, sy ^ 2), 2)\n      \n      # setup matrix to store densities\n      bivariate_normal <- matrix(0, n, n)\n      \n      # calculates the densities\n      for (i in seq_along(x)) {\n        for (j in seq_along(y)) {\n          bivariate_normal[i, j] <- dmvnorm(c(x[i], y[j]), mean = u, sigma = s)\n        }\n      }\n      \n      # plots\n      contour3D(x,\n                y,\n                bivariate_normal,\n                colvar = bivariate_normal,\n                phi = vertical_rotation,\n                theta = horizontal_rotation)\n    }\n    \n    # Output\n    contourplot(input$mu_x,input$mu_y,input$sx,input$sy,\n                        input$r,input$resolution,3.5,input$vr,input$hr)\n    \n  },\n  height = 1000, width = 800\n  )\n})\n",
    "created" : 1447823214738.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "193|32|239|2|\n",
    "hash" : "1253708245",
    "id" : "A338D318",
    "lastKnownWriteTime" : 1449170171,
    "path" : "C:/D/Study/James Scholar Program/Fall 2015 STAT 420/Honor/honor/server.R",
    "project_path" : "honor/server.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}