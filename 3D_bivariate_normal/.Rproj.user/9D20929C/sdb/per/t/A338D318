{
    "contents" : "shinyServer(function(input, output) {\n  # basic 3D Plot + Contour\n  output$distPlot <- renderPlot({\n    # Use mvtnorm and plot 3D libraries\n    library(mvtnorm)\n    library(plot3D)\n    \n    # helper function for 3D bivaraite normal distribution\n    bivariate_normal_3d <- function(mu_x,mu_y,sx,sy,r,n,cutoff,\n                                    vertical_rotation,horizontal_rotation) {\n      # Convert resolution to sample size\n      if (n == 'Low') {\n        n = 25\n      }\n      else{\n        n = 100\n      }\n      # Use mvtnorm library\n      library(mvtnorm)\n      # Create grid of interesting values.\n      x <- seq(mu_x - cutoff * sx, mu_x + cutoff * sx, length = n)\n      y <- seq(mu_y - cutoff * sy, mu_y + cutoff * sy, length = n)\n      \n      \n      # create the mean matrix (u) and covariance matrix (s)\n      u <- c(mu_x, mu_y)\n      covariance <- r * sx * sy\n      s <- matrix(c(sx ^ 2, covariance, covariance, sy ^ 2), 2)\n      \n      # setup matrix to store densities\n      bivariate_normal <- matrix(0, n, n)\n      \n      # calculates the densities\n      for (i in seq_along(x)) {\n        for (j in seq_along(y)) {\n          bivariate_normal[i, j] <-\n            dmvnorm(c(x[i], y[j]), mean = u, sigma = s)\n        }\n      }\n      \n      # Put 3D plot and contour plot together\n      par(mfrow = c(2,1))\n      \n      # Draw the 3D plot\n      persp3D(\n        x,\n        y,\n        bivariate_normal,\n        colvar = bivariate_normal,\n        phi = vertical_rotation,\n        theta = horizontal_rotation,\n        ticktype = \"detailed\",\n        expand = 0.5,\n        shade = 0.2,\n        xlab = \"x\",\n        ylab = \"y\",\n        zlab = \"z = f(x, y)\",\n        box = TRUE,\n        contour = TRUE\n      )\n    }\n    \n    # helper function for contour plot\n    bvn_countour_plot <- function(ux,\n                                  uy,\n                                  sx,\n                                  sy,\n                                  rho,\n                                  cx,\n                                  cy,\n                                  condition,\n                                  X,\n                                  Y) {\n      # Use ellipse library\n      library(ellipse)\n      \n      # Parameters\n      xlabel <- \"x\"\n      ylabel <- \"y\"\n      mu <- c(ux, uy)\n      s12 <- rho * sx * sy\n      sigma  <- cbind(c(sx ^ 2,s12),c(s12,sy ^ 2))\n      \n      xmax <- ux + 3.5 * sx\n      xmin <- ux - 3.5 * sx\n      \n      ymax <- uy + 3.5 * sy\n      ymin <- uy - 3.5 * sy\n      \n      # Basic contour plot\n      plot(\n        ellipse(sigma, level = 0.90)[,1] + mu[1],\n        ellipse(sigma, level = 0.90)[,2] + mu[2],\n        xlab = xlabel, ylab = ylabel,\n        xlim = c(xmin, xmax), ylim = c(ymin, ymax), type = \"l\"\n      )\n      \n      points(mu[1], mu[2], pch = 3)\n      \n      lines(\n        ellipse(sigma, level = 0.999)[,1] + mu[1],\n        ellipse(sigma, level = 0.999)[,2] + mu[2],\n        xlim = c(xmin, xmax), ylim = c(ymin, ymax), type = \"l\"\n      )\n      \n      lines(\n        ellipse(sigma, level = 0.99)[,1] + mu[1],\n        ellipse(sigma, level = 0.99)[,2] + mu[2],\n        xlim = c(xmin, xmax), ylim = c(ymin, ymax), type = \"l\"\n      )\n      \n      lines(\n        ellipse(sigma, level = 0.50)[,1] + mu[1],\n        ellipse(sigma, level = 0.50)[,2] + mu[2],\n        xlim = c(xmin, xmax), ylim = c(ymin, ymax), type = \"l\"\n      )\n      \n      \n      # Add shaded area if given X or Y\n      if (condition == TRUE) {\n        if (X == FALSE & Y == TRUE) {\n          abline(h = cy, col = \"blue\")\n          for (i in seq(cy, abs(cy) * 5, by = 0.1)) {\n            abline(h = i, col = \"blue\", lty = 3)\n          }\n        }\n        \n        if (Y == FALSE & X == TRUE) {\n          abline(v = cx, col = \"blue\")\n          for (i in seq(cx, abs(cx) * 5, by = 0.01)) {\n            abline(v = i, col = \"blue\", lty = 3)\n          }\n        }\n      }\n      \n      \n    }\n    \n    # Output\n    bivariate_normal_3d(\n      input$mu_x,input$mu_y,input$sx,input$sy,\n      input$r,input$resolution,3.5,input$vr,input$hr\n    )\n    \n    bvn_countour_plot(\n      input$mu_x,input$mu_y,input$sx,input$sy,\n      input$r,input$cx,input$cy,input$condition,input$X,input$Y\n    )\n  },\n  # Adjust output image size\n  height = 1000, width = 800)\n  #---------------------------------------------------------------------------\n  # 3D cutoff bivariate normal distribution given X or Y\n  output$cutoffPlot <- renderPlot({\n    # Use mvtnorm and plot 3D libraries\n    library(mvtnorm)\n    library(plot3D)\n    \n    # helper function for 3D cutoff bivariate normal distribution\n    \n    cutoff_3d <- function(mu_x,mu_y,sx,sy,r,n,cutoff,\n                          vertical_rotation,horizontal_rotation,cx,cy,condition,X,Y) {\n      # Convert resolution to sample size\n      if (n == 'Low') {\n        n = 25\n      }\n      else{\n        n = 100\n      }\n      \n      # Create grid of interesting values.\n      x <- seq(mu_x - cutoff * sx, mu_x + cutoff * sx, length = n)\n      y <- seq(mu_y - cutoff * sy, mu_y + cutoff * sy, length = n)\n      \n      \n      # create the mean matrix (u) and covariance matrix (s)\n      u <- c(mu_x, mu_y)\n      covariance <- r * sx * sy\n      s <- matrix(c(sx ^ 2, covariance, covariance, sy ^ 2), 2)\n      \n      # setup matrix to store densities\n      bivariate_normal <- matrix(0, n, n)\n      \n      # Given X\n      if (condition == TRUE) {\n        if (X == TRUE & Y == FALSE) {\n          for (i in which.min(abs(x - cx)):length(x)) {\n            for (j in seq_along(y)) {\n              bivariate_normal[i, j] <-\n                dmvnorm(c(x[i], y[j]), mean = u, sigma = s)\n            }\n          }\n          # plot\n          persp3D(\n            x,\n            y,\n            bivariate_normal,\n            colvar = bivariate_normal,\n            phi = vertical_rotation,\n            theta = horizontal_rotation,\n            ticktype = \"detailed\",\n            expand = 0.5,\n            shade = 0.2,\n            xlab = \"x\",\n            ylab = \"y\",\n            zlab = \"z = f(x, y)\"\n          )\n        }\n        # Given Y\n        if (Y == TRUE & X == FALSE) {\n          for (i in seq_along(x)) {\n            for (j in which.min(abs(y - cy)):length(y)) {\n              bivariate_normal[i, j] <-\n                dmvnorm(c(x[i], y[j]), mean = u, sigma = s)\n            }\n          }\n          # plots\n          persp3D(\n            x,\n            y,\n            bivariate_normal,\n            colvar = bivariate_normal,\n            phi = vertical_rotation,\n            theta = horizontal_rotation,\n            ticktype = \"detailed\",\n            expand = 0.5,\n            shade = 0.2,\n            xlab = \"x\",\n            ylab = \"y\",\n            zlab = \"z = f(x, y)\"\n          )\n        }\n      }\n    }\n    # Output\n    cutoff_3d(\n      input$mu_x,input$mu_y,input$sx,input$sy,input$r,input$resolution,3.5,input$vr,input$hr,input$cx,input$cy,input$condition,input$X,input$Y\n    )\n  },\n  \n  # Adjust output image size\n  height = 1000, width = 800)\n  #---------------------------------------------------------------------------\n  output$slicePlot <- renderPlot({\n    slice_3d <- function(mu_x,mu_y,sx,sy,r,n,cutoff,\n                         vertical_rotation,horizontal_rotation,\n                         cx,cy,condition,X,Y) {\n      # Convert resolution to sample size\n      if (n == 'Low') {\n        n = 25\n      }\n      else{\n        n = 100\n      }\n      # Use mvtnorm library and plot3D library\n      library(mvtnorm)\n      library(plot3D)\n      # Create grid of interesting values.\n      x <- seq(mu_x - cutoff * sx, mu_x + cutoff * sx, length = n)\n      y <- seq(mu_y - cutoff * sy, mu_y + cutoff * sy, length = n)\n      \n      \n      # create the mean matrix (u) and covariance matrix (s)\n      u <- c(mu_x, mu_y)\n      covariance <- r * sx * sy\n      s <- matrix(c(sx ^ 2, covariance, covariance, sy ^ 2), 2)\n      \n      # setup matrix to store densities\n      bivariate_normal <- matrix(0, n, n)\n      \n      \n      # Calculates the densities\n      \n      # Given X\n      if (condition == TRUE) {\n        if (Y == FALSE & X == TRUE) {\n          i = which.min(abs(x - cx))\n          for (j in seq_along(y)) {\n            bivariate_normal[i, j] <-\n              dmvnorm(c(x[i], y[j]), mean = u, sigma = s)\n          }\n          # plots\n          persp3D(\n            x,\n            y,\n            bivariate_normal,\n            colvar = bivariate_normal,\n            phi = vertical_rotation,\n            theta = horizontal_rotation,\n            ticktype = \"detailed\",\n            expand = 0.5,\n            shade = 0.2,\n            xlab = \"x\",\n            ylab = \"y\",\n            zlab = \"z = f(x, y)\"\n          )\n        }\n        # Given Y\n        if (X == FALSE & Y == TRUE) {\n          j = which.min(abs(y - cy))\n          for (i in seq_along(x)) {\n            bivariate_normal[i, j] <-\n              dmvnorm(c(x[i], y[j]), mean = u, sigma = s)\n          }\n          \n          # plots\n          persp3D(\n            x,\n            y,\n            bivariate_normal,\n            colvar = bivariate_normal,\n            phi = vertical_rotation,\n            theta = horizontal_rotation,\n            ticktype = \"detailed\",\n            expand = 0.5,\n            shade = 0.2,\n            xlab = \"x\",\n            ylab = \"y\",\n            zlab = \"z = f(x, y)\"\n          )\n        }\n      }\n    }\n    # Output\n    slice_3d(\n      input$mu_x,input$mu_y,input$sx,input$sy,input$r,\n      input$resolution,3.5,input$vr,input$hr,input$cx,\n      input$cy,input$condition,input$X,input$Y\n    )\n  },\n  # Adjust output image size\n  height = 1000, width = 800)\n})\n",
    "created" : 1447823214738.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "970026427",
    "id" : "A338D318",
    "lastKnownWriteTime" : 1450322845,
    "path" : "C:/D/Study/James Scholar Program/Fall 2015 STAT 420/Honor/honor/server.R",
    "project_path" : "honor/server.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}