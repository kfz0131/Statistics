{
    "contents" : "shinyServer(function(input, output) {\n  # 3D Plot\n  output$distPlot <- renderPlot({\n    library(mvtnorm)\n    library(plot3D)\n    # wrap-up function\n    bivariate_normal_3d <- function(mu_x,mu_y,sx,sy,r,n,cutoff,\n                                    vertical_rotation,horizontal_rotation) {\n      if (n == 'Low') {\n        n = 25\n      }\n      else{\n        n = 100\n      }\n      # Use mvtnorm library\n      library(mvtnorm)\n      # Create grid of interesting values.\n      x <- seq(mu_x - cutoff * sx, mu_x + cutoff * sx, length = n)\n      y <- seq(mu_y - cutoff * sy, mu_y + cutoff * sy, length = n)\n      \n      \n      # create the mean matrix (u) and covariance matrix (s)\n      u <- c(mu_x, mu_y)\n      covariance <- r * sx * sy\n      s <- matrix(c(sx ^ 2, covariance, covariance, sy ^ 2), 2)\n      \n      # setup matrix to store densities\n      bivariate_normal <- matrix(0, n, n)\n      \n      # calculates the densities\n      for (i in seq_along(x)) {\n        for (j in seq_along(y)) {\n          bivariate_normal[i, j] <-\n            dmvnorm(c(x[i], y[j]), mean = u, sigma = s)\n        }\n      }\n      \n      # 3D plot\n      par(mfrow = c(2,1))\n      \n      persp3D(\n        x,\n        y,\n        bivariate_normal,\n        colvar = bivariate_normal,\n        phi = vertical_rotation,\n        theta = horizontal_rotation,\n        ticktype = \"detailed\",\n        expand = 0.5,\n        shade = 0.2,\n        xlab = \"x\",\n        ylab = \"y\",\n        zlab = \"z = f(x, y)\",\n        box = TRUE,\n        contour = TRUE\n      )\n    }\n    \n    #wrap-up function\n    bvn_countour_plot <- function(ux,\n                                  uy,\n                                  sx,\n                                  sy,\n                                  rho,\n                                  cx,\n                                  cy) {\n      library(ellipse)\n      xlabel <- \"x\"\n      ylabel <- \"y\"\n      mu <- c(ux, uy)\n      s12 <- rho * sx * sy\n      sigma  <- cbind(c(sx ^ 2,s12),c(s12,sy ^ 2))\n      \n      xmax <- ux + 3.5 * sx\n      xmin <- ux - 3.5 * sx\n      \n      ymax <- uy + 3.5 * sy\n      ymin <- uy - 3.5 * sy\n      \n      # Basic contour plot\n      plot(\n        ellipse(sigma, level = 0.90)[,1] + mu[1],\n        ellipse(sigma, level = 0.90)[,2] + mu[2],\n        xlab = xlabel, ylab = ylabel,\n        xlim = c(xmin, xmax), ylim = c(ymin, ymax), type = \"l\"\n      )\n      \n      points(mu[1], mu[2], pch = 3)\n      \n      lines(\n        ellipse(sigma, level = 0.999)[,1] + mu[1],\n        ellipse(sigma, level = 0.999)[,2] + mu[2],\n        xlim = c(xmin, xmax), ylim = c(ymin, ymax), type = \"l\"\n      )\n      \n      lines(\n        ellipse(sigma, level = 0.99)[,1] + mu[1],\n        ellipse(sigma, level = 0.99)[,2] + mu[2],\n        xlim = c(xmin, xmax), ylim = c(ymin, ymax), type = \"l\"\n      )\n      \n      lines(\n        ellipse(sigma, level = 0.50)[,1] + mu[1],\n        ellipse(sigma, level = 0.50)[,2] + mu[2],\n        xlim = c(xmin, xmax), ylim = c(ymin, ymax), type = \"l\"\n      )\n      \n      \n      # Add shaded area if given X or Y\n      if (!is.null(cy)) {\n        abline(h = cy, col = \"blue\")\n        for (i in seq(cy, abs(cy) * 5, by = 0.1)) {\n          abline(h = i, col = \"blue\", lty = 3)\n        }\n      }\n      \n      if (!is.null(cx)) {\n        abline(v = cx, col = \"blue\")\n        for (i in seq(cx, abs(cx) * 5, by = 0.01)) {\n          abline(v = i, col = \"blue\", lty = 3)\n        }\n      }\n      \n      \n    }\n    \n    # Output\n    bivariate_normal_3d(\n      input$mu_x,input$mu_y,input$sx,input$sy,\n      input$r,input$resolution,3.5,input$vr,input$hr\n    )\n    bvn_countour_plot(input$mu_x,input$mu_y,input$sx,input$sy,\n                      input$r,input$cx,input$cy)\n  },\n  height = 1000, width = 800)\n  #---------------------------------------------------------------------------\n  # Condition Plot\n  output$conditionPlot <- renderPlot({\n    library(mvtnorm)\n    library(plot3D)\n    # wrap-up function\n    \n    condition_3d <- function(mu_x,mu_y,sx,sy,r,n,cutoff,\n                             vertical_rotation,horizontal_rotation,cx,cy) {\n      if (n == 'Low') {\n        n = 25\n      }\n      else{\n        n = 100\n      }\n      # Use mvtnorm library and plot3D library\n      library(mvtnorm)\n      library(plot3D)\n      # Create grid of interesting values.\n      x <- seq(mu_x - cutoff * sx, mu_x + cutoff * sx, length = n)\n      y <- seq(mu_y - cutoff * sy, mu_y + cutoff * sy, length = n)\n      \n      \n      # create the mean matrix (u) and covariance matrix (s)\n      u <- c(mu_x, mu_y)\n      covariance <- r * sx * sy\n      s <- matrix(c(sx ^ 2, covariance, covariance, sy ^ 2), 2)\n      \n      # setup matrix to store densities\n      bivariate_normal <- matrix(0, n, n)\n      \n      # calculates the densities\n      if (missing(cx) & missing(cy)) {\n        for (i in seq_along(x)) {\n          for (j in seq_along(y)) {\n            bivariate_normal[i, j] <-\n              dmvnorm(c(x[i], y[j]), mean = u, sigma = s)\n          }\n        }\n        # plots\n        persp3D(\n          x,\n          y,\n          bivariate_normal,\n          colvar = bivariate_normal,\n          phi = vertical_rotation,\n          theta = horizontal_rotation,\n          ticktype = \"detailed\",\n          expand = 0.5,\n          shade = 0.2,\n          xlab = \"x\",\n          ylab = \"y\",\n          zlab = \"z = f(x, y)\"\n        )\n      }\n      # condition on given X\n      else if (missing(cy)) {\n        for (i in which.min(abs(x - cx)):length(x)) {\n          for (j in seq_along(y)) {\n            bivariate_normal[i, j] <-\n              dmvnorm(c(x[i], y[j]), mean = u, sigma = s)\n          }\n        }\n        # plots\n        persp3D(\n          x,\n          y,\n          bivariate_normal,\n          colvar = bivariate_normal,\n          phi = vertical_rotation,\n          theta = horizontal_rotation,\n          ticktype = \"detailed\",\n          expand = 0.5,\n          shade = 0.2,\n          xlab = \"x\",\n          ylab = \"y\",\n          zlab = \"z = f(x, y)\"\n        )\n      }\n      # condition on given Y\n      else if (missing(cx)) {\n        for (i in seq_along(x)) {\n          for (j in which.min(abs(y - cy)):length(y)) {\n            bivariate_normal[i, j] <-\n              dmvnorm(c(x[i], y[j]), mean = u, sigma = s)\n          }\n        }\n        # plots\n        persp3D(\n          x,\n          y,\n          bivariate_normal,\n          colvar = bivariate_normal,\n          phi = vertical_rotation,\n          theta = horizontal_rotation,\n          ticktype = \"detailed\",\n          expand = 0.5,\n          shade = 0.2,\n          xlab = \"x\",\n          ylab = \"y\",\n          zlab = \"z = f(x, y)\"\n        )\n      }\n      # For debug use. This should not happen\n      else{\n        for (i in which.min(abs(x - cx)):length(x)) {\n          for (j in  which.min(abs(y - cy)):length(y)) {\n            bivariate_normal[i, j] <-\n              dmvnorm(c(x[i], y[j]), mean = u, sigma = s)\n          }\n        }\n        # plots\n        persp3D(\n          x,\n          y,\n          bivariate_normal,\n          colvar = bivariate_normal,\n          phi = vertical_rotation,\n          theta = horizontal_rotation,\n          ticktype = \"detailed\",\n          expand = 0.5,\n          shade = 0.2,\n          xlab = \"x\",\n          ylab = \"y\",\n          zlab = \"z = f(x, y)\"\n        )\n      }\n    }\n    # Output\n    condition_3d(\n      input$mu_x,input$mu_y,input$sx,input$sy,input$r,input$resolution,3.5,input$vr,input$hr,cx =\n        0.02\n    )\n  },\n  height = 1000, width = 800)\n  #---------------------------------------------------------------------------\n  output$slicePlot <- renderPlot({\n    slice_3d <- function(mu_x,mu_y,sx,sy,r,n,cutoff,\n                         vertical_rotation,horizontal_rotation,\n                         cx,cy,condition,X,Y) {\n      if (n == 'Low') {\n        n = 25\n      }\n      else{\n        n = 100\n      }\n      # Use mvtnorm library and plot3D library\n      library(mvtnorm)\n      library(plot3D)\n      # Create grid of interesting values.\n      x <- seq(mu_x - cutoff * sx, mu_x + cutoff * sx, length = n)\n      y <- seq(mu_y - cutoff * sy, mu_y + cutoff * sy, length = n)\n      \n      \n      # create the mean matrix (u) and covariance matrix (s)\n      u <- c(mu_x, mu_y)\n      covariance <- r * sx * sy\n      s <- matrix(c(sx ^ 2, covariance, covariance, sy ^ 2), 2)\n      \n      # setup matrix to store densities\n      bivariate_normal <- matrix(0, n, n)\n      \n      \n      # calculates the densities\n      \n      # condition on given X\n      if (condition == TRUE) {\n        if (Y == FALSE) {\n          #i = which.min(abs(x - cx))\n          for (i in which.min(abs(x - cx))-1:which.min(abs(x - cx))+1){\n          for (j in seq_along(y)) {\n            bivariate_normal[i, j] <-\n              dnorm(j, mean = (mu_y + (r * sy * (cx - mu_x)) /\n                                               sx), sd = sqrt((1 - r ^ 2) * sy ^ 2))\n          }}\n          # plots\n          persp3D(\n            x,\n            y,\n            bivariate_normal,\n            colvar = bivariate_normal,\n            phi = vertical_rotation,\n            theta = horizontal_rotation,\n            ticktype = \"detailed\",\n            expand = 0.5,\n            shade = 0.2,\n            xlab = \"x\",\n            ylab = \"y\",\n            zlab = \"z = f(x, y)\"\n          )\n        }\n        # condition on given Y\n        if (X == FALSE) {\n          j = which.min(abs(y - cy))\n          for (i in seq_along(x)) {\n            bivariate_normal[i, j] <-\n              dmvnorm(c(x[i], y[j]), mean = u, sigma = s)\n          }\n          \n          # plots\n          persp3D(\n            x,\n            y,\n            bivariate_normal,\n            colvar = bivariate_normal,\n            phi = vertical_rotation,\n            theta = horizontal_rotation,\n            ticktype = \"detailed\",\n            expand = 0.5,\n            shade = 0.2,\n            xlab = \"x\",\n            ylab = \"y\",\n            zlab = \"z = f(x, y)\"\n          )\n        }\n      }\n    }\n    # Output\n    slice_3d(\n      input$mu_x,input$mu_y,input$sx,input$sy,input$r,\n      input$resolution,3.5,input$vr,input$hr,input$cx,\n      input$cy,input$condition,input$X,input$Y\n    )\n  },\n    height = 1000, width = 800\n  )\n})\n",
    "created" : 1447823214738.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3644517181",
    "id" : "A338D318",
    "lastKnownWriteTime" : 1450196621,
    "path" : "C:/D/Study/James Scholar Program/Fall 2015 STAT 420/Honor/honor/server.R",
    "project_path" : "honor/server.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}